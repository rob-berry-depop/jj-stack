// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Os from "os";
import * as $$Ink from "ink";
import * as Path from "path";
import Which from "which";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as BookmarkSelectionComponent from "./BookmarkSelectionComponent.res.mjs";

function sleep(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), ms);
              }));
}

function changeIdToLogEntry(changeGraph, changeId) {
  var segment = Core__Option.getExn(changeGraph.bookmarkedChangeIdToSegment.get(changeId), undefined);
  return Core__Option.getExn(segment[0], undefined);
}

function isInteractiveUINeeded(segments) {
  return segments.some(function (segment) {
              return segment.bookmarks.length > 1;
            });
}

function getDirectBookmarkSelections(segments) {
  return segments.map(function (segment) {
              if (segment.bookmarks.length !== 1) {
                console.error("âŒ Internal error: Expected single bookmark but found " + segment.bookmarks.length.toString());
                Js_exn.raiseError("Invalid state: getDirectBookmarkSelections called with multi-bookmark segment");
              }
              return Core__Option.getExn(segment.bookmarks[0], undefined);
            });
}

async function resolveBookmarkSelectionsWithUI(analysis) {
  var segments = analysis.relevantSegments;
  if (segments.length === 0) {
    console.error("âŒ No segments provided for bookmark selection");
    return Js_exn.raiseError("No segments to process");
  } else if (isInteractiveUINeeded(segments)) {
    console.log("ðŸ”€ Found changes with multiple bookmarks, opening interactive selector...");
    console.log();
    return await new Promise((function (resolve, reject) {
                  var inkInstanceRef = {
                    contents: undefined
                  };
                  var component = JsxRuntime.jsx(BookmarkSelectionComponent.make, {
                        segments: segments.slice().reverse(),
                        onComplete: (function (bookmarks) {
                            var instance = inkInstanceRef.contents;
                            if (instance !== undefined) {
                              instance.unmount();
                            }
                            if (bookmarks.length !== segments.length) {
                              console.error("âŒ Selection mismatch: expected " + segments.length.toString() + " bookmarks, got " + bookmarks.length.toString());
                              return reject({
                                          RE_EXN_ID: "Failure",
                                          _1: "Selection count mismatch"
                                        });
                            } else {
                              return resolve(bookmarks.slice().reverse());
                            }
                          })
                      });
                  var inkInstance = $$Ink.render(component);
                  inkInstanceRef.contents = inkInstance;
                }));
  } else {
    console.log("ðŸ“‹ All changes have single bookmarks, proceeding automatically...");
    return getDirectBookmarkSelections(segments);
  }
}

async function resolveBookmarkSelections(analysis) {
  return await resolveBookmarkSelectionsWithUI(analysis);
}

function getJJPath() {
  var envPath = Js_dict.get(process.env, "JJ_PATH");
  var checkCommonPaths = function (pathIndex, commonPaths) {
    if (pathIndex >= commonPaths.length) {
      return Promise.resolve(undefined);
    }
    var currentPath = Core__Option.getExn(commonPaths[pathIndex], undefined);
    return Js_promise.then_((function (whichResult) {
                  if (whichResult == null) {
                    return checkCommonPaths(pathIndex + 1 | 0, commonPaths);
                  } else {
                    return Promise.resolve(whichResult);
                  }
                }), Which(currentPath, {
                    nothrow: true
                  }));
  };
  if (envPath !== undefined) {
    return Js_promise.then_((function (whichResult) {
                  if (whichResult == null) {
                    return Promise.reject(Js_exn.raiseError("Configured JJ_PATH is not an executable file: " + envPath));
                  } else {
                    return Promise.resolve({
                                filepath: envPath,
                                source: "configured"
                              });
                  }
                }), Which(envPath, {
                    nothrow: true
                  }));
  } else {
    return Js_promise.then_((function (jjInPath) {
                  if (!(jjInPath == null)) {
                    return Promise.resolve({
                                filepath: jjInPath,
                                source: "path"
                              });
                  }
                  var homeDir = Os.homedir();
                  var commonPaths = [
                    Path.join(homeDir, ".cargo", "bin", "jj"),
                    Path.join(homeDir, ".cargo", "bin", "jj.exe"),
                    Path.join(homeDir, ".nix-profile", "bin", "jj"),
                    Path.join(homeDir, ".local", "bin", "jj"),
                    Path.join(homeDir, "bin", "jj"),
                    "/usr/bin/jj",
                    "/home/linuxbrew/.linuxbrew/bin/jj",
                    "/usr/local/bin/jj",
                    "/opt/homebrew/bin/jj",
                    "/opt/local/bin/jj"
                  ];
                  return Js_promise.then_((function (foundCommonPath) {
                                if (foundCommonPath !== undefined) {
                                  return Promise.resolve({
                                              filepath: foundCommonPath,
                                              source: "common"
                                            });
                                } else {
                                  return Promise.reject(Js_exn.raiseError("jj CLI not found in PATH nor in common locations."));
                                }
                              }), checkCommonPaths(0, commonPaths));
                }), Which("jj", {
                    nothrow: true
                  }));
  }
}

export {
  sleep ,
  changeIdToLogEntry ,
  isInteractiveUINeeded ,
  getDirectBookmarkSelections ,
  resolveBookmarkSelectionsWithUI ,
  resolveBookmarkSelections ,
  getJJPath ,
}
/* os Not a pure module */
