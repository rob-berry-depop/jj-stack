// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Readline from "readline";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function sleep(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), ms);
              }));
}

function changeIdToLogEntry(changeGraph, changeId) {
  var segment = Core__Option.getExn(changeGraph.bookmarkedChangeIdToSegment.get(changeId), undefined);
  return Core__Option.getExn(segment[0], undefined);
}

async function promptUser(questionText) {
  var rl = Readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
  var answer = await rl.question(questionText);
  rl.close();
  return answer.trim();
}

function formatSegmentWithMultipleBookmarks(segment) {
  var availableNames = segment.bookmarks.map(function (b) {
          return b.name;
        }).join(", ");
  var bookmarksWithRemotes = segment.bookmarks.filter(function (b) {
        return b.hasRemote;
      });
  var withRemotes = bookmarksWithRemotes.map(function (b) {
          return b.name;
        }).join(", ");
  var remotesInfo = withRemotes === "" ? "none have remote branches" : "bookmarks with remote branches: " + withRemotes;
  var firstBookmark = Core__Option.getExn(segment.bookmarks[0], undefined);
  var changeId = firstBookmark.changeId;
  return "Change " + changeId + ": multiple bookmarks [" + availableNames + "] (" + remotesInfo + ")";
}

async function promptFromAllBookmarks(bookmarks) {
  console.log("\nAvailable bookmarks:");
  bookmarks.forEach(function (bookmark, i) {
        var remoteStatus = bookmark.hasRemote ? (
            bookmark.isSynced ? " (has remote, synced)" : " (has remote, not synced)"
          ) : " (no remote)";
        console.log("  " + (i + 1 | 0).toString() + ". " + bookmark.name + remoteStatus);
      });
  var maxChoice = bookmarks.length;
  var promptChoice = async function () {
    var answer = await promptUser("\nSelect bookmark (1-" + maxChoice.toString() + "): ");
    var choice = Core__Int.fromString(answer, undefined);
    if (choice !== undefined && choice >= 1 && choice <= maxChoice) {
      return Core__Option.getExn(bookmarks[choice - 1 | 0], undefined);
    }
    console.log("Invalid choice. Please enter a number between 1 and " + maxChoice.toString() + ".");
    return await promptChoice();
  };
  return await promptChoice();
}

async function promptBookmarkSelectionForSegment(segment) {
  console.log("\nâš ï¸  Multiple bookmarks found on the same change:");
  console.log(formatSegmentWithMultipleBookmarks(segment));
  var bookmarksWithRemotes = segment.bookmarks.filter(function (b) {
        return b.hasRemote;
      });
  if (bookmarksWithRemotes.length !== 1) {
    return await promptFromAllBookmarks(segment.bookmarks);
  }
  var defaultBookmark = Core__Option.getExn(bookmarksWithRemotes[0], undefined);
  var questionText = "\nOnly '" + defaultBookmark.name + "' has a remote branch. Use it? [Y/n]: ";
  var answer = await promptUser(questionText);
  if (answer === "" || answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
    return defaultBookmark;
  } else {
    return await promptFromAllBookmarks(segment.bookmarks);
  }
}

async function resolveBookmarkSelections(analysis) {
  var segmentsWithMultipleBookmarks = analysis.relevantSegments.filter(function (segment) {
        return segment.bookmarks.length > 1;
      });
  if (segmentsWithMultipleBookmarks.length > 0) {
    console.log("\nðŸ”€ Found " + segmentsWithMultipleBookmarks.length.toString() + " segment(s) with multiple bookmarks:");
  }
  var selectedBookmarks = [];
  for(var i = 0 ,i_finish = analysis.relevantSegments.length; i < i_finish; ++i){
    var segment = Core__Option.getExn(analysis.relevantSegments[i], undefined);
    if (segment.bookmarks.length === 1) {
      selectedBookmarks.push(Core__Option.getExn(segment.bookmarks[0], undefined));
    } else {
      var selectedBookmark = await promptBookmarkSelectionForSegment(segment);
      selectedBookmarks.push(selectedBookmark);
      console.log("âœ… Selected '" + selectedBookmark.name + "' for change " + selectedBookmark.changeId);
    }
  }
  if (segmentsWithMultipleBookmarks.length > 0) {
    console.log("\nâœ¨ All bookmark selections completed!");
  }
  return selectedBookmarks;
}

export {
  sleep ,
  changeIdToLogEntry ,
  promptUser ,
  formatSegmentWithMultipleBookmarks ,
  promptFromAllBookmarks ,
  promptBookmarkSelectionForSegment ,
  resolveBookmarkSelections ,
}
/* readline Not a pure module */
