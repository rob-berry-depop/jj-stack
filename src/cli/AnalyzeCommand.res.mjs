// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Ink from "ink";
import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as SubmitCommand from "./SubmitCommand.res.mjs";
import * as SubmitJs from "../lib/submit.js";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as AnalyzeCommandComponent from "./AnalyzeCommandComponent.res.mjs";

function buildChangeGraph(prim) {
  return JjUtilsJs.buildChangeGraph(prim);
}

function getExistingPRs(prim0, prim1, prim2, prim3) {
  return SubmitJs.getExistingPRs(prim0, prim1, prim2, prim3);
}

async function analyzeCommand(jjFunctions, remote, dryRun) {
  console.log("Fetching from remote...");
  try {
    await jjFunctions.gitFetch();
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      console.error("Error fetching from remote: " + Core__Option.getOr(error._1.message, "Unknown error"));
    } else {
      throw error;
    }
  }
  console.log("Building change graph from user bookmarks...");
  var changeGraph = await JjUtilsJs.buildChangeGraph(jjFunctions);
  if (changeGraph.excludedBookmarkCount > 0) {
    console.log("ℹ️  Found " + changeGraph.excludedBookmarkCount.toString() + " bookmarks on merge commits or their descendants, ignoring.\n   jj-stack works with linear stacking workflows. Consider using 'jj rebase' to linearize your history before creating stacked pull requests.");
    console.log();
  }
  if (changeGraph.stacks.length === 0) {
    console.log("No bookmark stacks found. Create bookmarks with `jj bookmark create` first.");
    PervasivesU.exit(0);
  }
  var inDegrees = new Map();
  changeGraph.bookmarkedChangeAdjacencyList.forEach(function (parentChangeId) {
        inDegrees.set(parentChangeId, Core__Option.getOr(inDegrees.get(parentChangeId), 0) + 1 | 0);
      });
  var queue = Array.from(changeGraph.stackLeafs).sort(function (a, b) {
        var logEntryA = Utils.changeIdToLogEntry(changeGraph, a);
        var logEntryB = Utils.changeIdToLogEntry(changeGraph, b);
        var difference = logEntryB.committedAt.getTime() - logEntryA.committedAt.getTime();
        if (difference > 0) {
          return 1;
        } else if (difference < 0) {
          return -1;
        } else {
          return 0;
        }
      });
  var topSort = [];
  while(queue.length > 0) {
    var changeId = Core__Option.getExn(queue.shift(), undefined);
    topSort.push(changeId);
    var parent = changeGraph.bookmarkedChangeAdjacencyList.get(changeId);
    if (parent !== undefined) {
      var newParentInDegrees = Core__Option.getExn(inDegrees.get(parent), undefined) - 1 | 0;
      if (newParentInDegrees > 0) {
        inDegrees.set(parent, newParentInDegrees);
      } else {
        queue.unshift(parent);
      }
    }
    
  };
  var output = [];
  var columns = [];
  topSort.forEach(function (changeId) {
        var prefColumnIdx = columns.findIndex(function (v) {
              return v === changeId;
            });
        if (prefColumnIdx === -1) {
          columns.push(changeId);
        }
        var changeColumnIdx = prefColumnIdx === -1 ? columns.length - 1 | 0 : prefColumnIdx;
        var nextRow = [];
        for(var _for = 0; _for < changeColumnIdx; ++_for){
          nextRow.push(" │");
        }
        nextRow.push(" ○");
        for(var _for$1 = changeColumnIdx + 1 | 0 ,_for_finish = columns.length; _for$1 < _for_finish; ++_for$1){
          nextRow.push(" │");
        }
        output.push({
              chars: nextRow,
              changeId: changeId
            });
        var parent = changeGraph.bookmarkedChangeAdjacencyList.get(changeId);
        if (parent !== undefined) {
          var parentColumnIdx = columns.findIndex(function (id) {
                return id === parent;
              });
          if (parentColumnIdx !== -1 && parentColumnIdx < changeColumnIdx) {
            columns.splice(changeColumnIdx, 1);
            var nextRow$1 = [];
            for(var _for$2 = 0; _for$2 < parentColumnIdx; ++_for$2){
              nextRow$1.push(" │");
            }
            nextRow$1.push(" ├");
            for(var _for$3 = parentColumnIdx + 1 | 0; _for$3 < changeColumnIdx; ++_for$3){
              nextRow$1.push("─│");
            }
            nextRow$1.push("─╯");
            for(var _for$4 = changeColumnIdx + 1 | 0 ,_for_finish$1 = columns.length; _for$4 < _for_finish$1; ++_for$4){
              nextRow$1.push(" │");
            }
            output.push({
                  chars: nextRow$1,
                  changeId: undefined
                });
            return ;
          }
          columns[changeColumnIdx] = parent;
          output.push({
                chars: " │".repeat(columns.length).split(""),
                changeId: undefined
              });
          return ;
        }
        if (changeColumnIdx > 0) {
          var nextRow$2 = [];
          nextRow$2.push(" ├");
          for(var _for$5 = 1; _for$5 < changeColumnIdx; ++_for$5){
            nextRow$2.push("─│");
          }
          for(var _for$6 = changeColumnIdx ,_for_finish$2 = columns.length; _for$6 < _for_finish$2; ++_for$6){
            nextRow$2.push("─╯");
          }
          columns.splice(changeColumnIdx, 1);
          output.push({
                chars: nextRow$2,
                changeId: undefined
              });
          return ;
        }
        output.push({
              chars: " │".repeat(columns.length).split(""),
              changeId: undefined
            });
      });
  console.log();
  var changeId$1 = await new Promise((function (resolve, _reject) {
          var inkInstanceRef = {
            contents: undefined
          };
          var inkInstance = $$Ink.render(JsxRuntime.jsx(AnalyzeCommandComponent.make, {
                    changeGraph: changeGraph,
                    output: output,
                    topSort: topSort,
                    onSelect: (function (changeId) {
                        var instance = inkInstanceRef.contents;
                        if (instance !== undefined) {
                          instance.unmount();
                        }
                        resolve(changeId);
                      })
                  }));
          inkInstanceRef.contents = inkInstance;
        }));
  var segment = Core__Option.getExn(changeGraph.bookmarkedChangeIdToSegment.get(changeId$1), undefined);
  var logEntry = Core__Option.getExn(segment[0], undefined);
  return await SubmitCommand.runSubmit(jjFunctions, Core__Option.getExn(logEntry.localBookmarks[0], undefined), changeGraph, dryRun, remote);
}

export {
  buildChangeGraph ,
  getExistingPRs ,
  analyzeCommand ,
}
/* ink Not a pure module */
