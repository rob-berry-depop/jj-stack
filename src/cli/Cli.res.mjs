// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as AuthCommand from "./AuthCommand.res.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as SubmitCommand from "./SubmitCommand.res.mjs";
import * as AnalyzeCommand from "./AnalyzeCommand.res.mjs";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function createJjFunctions(prim) {
  return JjUtilsJs.createJjFunctions(prim);
}

function isGitHubRemote(prim) {
  return JjUtilsJs.isGitHubRemote(prim);
}

var help = "ğŸ”§ jj-stack - Jujutsu Git workflow automation\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nUSAGE:\n  jj-stack [COMMAND] [OPTIONS]\n\nCOMMANDS:\n  submit <bookmark>     Submit a bookmark and all downstack bookmarks as PRs\n    --dry-run           Show what would be done without making changes\n    --remote <name>     Use the specified Git remote (must be a GitHub remote)\n\n  auth test             Test GitHub authentication\n  auth help             Show authentication help\n\n  help, --help, -h      Show this help message\n\nDEFAULT BEHAVIOR:\n  Running jj-stack without arguments analyzes and displays the current\n  graph of stacked bookmarks.\n\nEXAMPLES:\n  jj-stack                        # Show change graph\n  jj-stack submit feature-branch  # Submit feature-branch and downstack as PRs\n  jj-stack submit feature-branch --dry-run  # Preview what would be done\n  jj-stack submit feature-branch --remote upstream  # Use a specific remote\n  jj-stack auth test              # Test GitHub authentication\n\nFor more information, visit: https://github.com/keanemind/jj-stack\n";

function extractGlobalFlags(args) {
  var idx = args.findIndex(function (arg) {
        return arg === "--remote";
      });
  if (!(idx >= 0 && (idx + 1 | 0) < args.length)) {
    return [
            args,
            "origin"
          ];
  }
  var remoteName = Belt_Option.getWithDefault(args[idx + 1 | 0], "origin");
  var filteredArgs = args.slice(0, idx).concat(args.slice(idx + 2 | 0, args.length));
  return [
          filteredArgs,
          remoteName
        ];
}

async function main() {
  try {
    var jjPathResult = await Utils.getJJPath();
    var jjConfig = {
      binaryPath: jjPathResult.filepath
    };
    var jjFunctions = JjUtilsJs.createJjFunctions(jjConfig);
    var args = process.argv.slice(2, process.argv.length);
    var match = extractGlobalFlags(args);
    var remoteName = match[1];
    var filteredArgs = match[0];
    var knownCommands = [
      "submit",
      "auth",
      "help",
      "--help",
      "-h"
    ];
    var command = filteredArgs[0];
    var isKnownCommand = Belt_Option.getWithDefault(Belt_Option.map(command, (function (cmd) {
                return knownCommands.includes(cmd);
              })), false);
    if (command === undefined) {
      return await AnalyzeCommand.analyzeCommand(jjFunctions, remoteName);
    }
    if (!isKnownCommand) {
      return await AnalyzeCommand.analyzeCommand(jjFunctions, remoteName);
    }
    switch (command) {
      case "auth" :
          var match$1 = filteredArgs[1];
          if (match$1 === "test") {
            return await AuthCommand.authTestCommand();
          } else {
            return AuthCommand.authHelpCommand();
          }
      case "--help" :
      case "-h" :
      case "help" :
          console.log(help);
          return ;
      case "submit" :
          var bookmarkName = filteredArgs[1];
          if (bookmarkName !== undefined) {
            var isDryRun = filteredArgs.includes("--dry-run");
            var remotes = jjFunctions.getGitRemoteList();
            var foundRemote = remotes.find(function (r) {
                  return r.name === remoteName;
                });
            if (foundRemote !== undefined) {
              if (!JjUtilsJs.isGitHubRemote(foundRemote.url)) {
                console.error("âŒ Remote '" + remoteName + "' is not a GitHub remote. Only GitHub remotes are supported.");
                process.exit(1);
              }
              return await SubmitCommand.submitCommand(jjFunctions, bookmarkName, {
                          dryRun: isDryRun,
                          remote: remoteName
                        });
            } else {
              console.error("âŒ Remote '" + remoteName + "' does not exist.");
              process.exit(1);
              return ;
            }
          }
          console.error("Usage: jj-stack submit <bookmark-name> [--dry-run] [--remote <name>]");
          process.exit(1);
          return ;
      default:
        return ;
    }
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      var message = error._1.message;
      if (message !== undefined) {
        console.error("An error occurred: " + message);
        process.exit(1);
      } else {
        console.error("An unknown error occurred.");
        process.exit(1);
      }
      return ;
    }
    console.error("An unknown error occurred.");
    process.exit(1);
    return ;
  }
}

export {
  createJjFunctions ,
  isGitHubRemote ,
  help ,
  extractGlobalFlags ,
  main ,
}
/* Utils Not a pure module */
